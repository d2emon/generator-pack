import random
from dice.dice import Dice


"""
Самое время для случайного столкновения

Когда и как часто нужно вставлять в свои игры энкаунтеры-случайные столкновения
с врагами и мирными встречными персонажами?

Самое время для случайного столкновения в настольной ролевой игре

Сегодня у меня для вас небольшая кучка прикладных правил, под образным
названием «как добавить порядка в случайные столкновения». Касается она той
части путешествий, которую обычно игроки и ведущие склонны пропускать в плане
отыгрыша – собственно перемещения из точки А к точке Б. Ну вы знаете эту тему:

«Вы в пути 6 часов, так, что тут у нас… ага! Банда орков! Так, разобрались,
двигаем дальше – впереди ещё полдня дороги».

В принципе, это работает и всех устраивает. Лишь одна деталь всегда вызывала у
меня легкое желание как-то урегулировать процесс: насколько часто должны
встречаться в пути пресловутые «банды орков» и вообще, насколько частыми будут
подобные случайные встречи (энкаунтеры)?

В итоге, получилось то что вы видите перед собой, и сейчас я расскажу как это
работает.

Виды событий
Столкновение
Путевая встреча/Возможное столкновение
Привал/Возможное столкновение
Подсказка
Трата ресурсов
Задержка в пути
Столкновение – хо-хо, а вот и орки. В смысле, сейчас будет драка.

Путевая встреча – не связанное с «военными действиями» событие, характерное для этой местности. Встреча с купеческими караванами на дороге или с дровосеком в лесу – вот и все примеры.

Привал – если вы сейчас же не сделаете привал (короткий, на 1 час), то или лошадь захромает, или уровень усталости группы повысится.

Возможное столкновение – при неблагоприятных условиях, плохих бросках, злобном ведущем и т.п. ситуациях, используйте этот вариант. В принципе, он ничем не отличается от первоначального, кроме одного – вам предстоит встреча с кем-то совершенно не в духе. При «путевой встрече» это могут быть нечистые на руку караванщики, которые, если группа искателей приключений кажется им легкой добычей, нападут. При «привале» — герои встретятся с облюбовавшим это же место медведем или патрулем зверолюдей.

Подсказка – вы получили относительно ценную информацию. Узнали о том, что поблизости чудовища, что рядом находится деревня, что недавно здесь проходил путешественник и т.п.

Трата ресурсов – ох, в пути возникла ситуация, когда вам пришлось израсходовать часть ресурсов: запас дров, дополнительные порции провианта, веревку и т.п.

Задержка в пути — что-то пошло не так и вы потеряли время, заблудились, вынуждены идти кружным путем, подвернули ногу и т.п.

Дополнительные таблицы для столкновений
Неожиданность
Обе стороны делают бросок 1d6 и при выпадении значений 1-2, появление противника для них оказывается полной неожиданностью, а сами они будут считаться застигнутыми врасплох.

Расстояние
Чтобы узнать расстояние на котором враги замечают друг друга, бросьте 1d6 (днем) и 1d4 (ночью), модифицировав этот значение зоной видимости характерной для этого типа местности. Результаты:

Но с к носу (ближний бой возможен с ходу)
На расстоянии нескольких шагов (минимальный предел дистанционного боя без штрафов)
Среднее (1d6 х 30 футов, на дистанции прямого выстрела)
Дальнее (2d6+6 х 30 футов, вне прямой видимости)
Сверхдальнее (2d6+12 х 30 футов, вне прямой видимости)
На пределе видимости (10 минут бодрым шагом, вне прямой видимости)
Возможность бегства
Если вы не застигнуты врасплох, а расстояние до противника минимум среднее, у вас есть все шансы уклонится от боя, но шанс успеха зависит как от размера вашей группы, так и от размера группы противников. Сделайте бросок 1d20 и используйте проверочное число из таблицы ниже. В случае если результат броска выше или равен проверочному числу – вам удалось избежать боя.

Размер группы	Проверочное число при броске 2d10
Одиночка	15
Маленькая (меньше 4)	17
Средняя (5-12)	19
Большая (13-24)	21
Огромная (25+)	23
Обратите внимание: если враг застигнут врасплох, а расстояние до противника минимум среднее – вы можете уклониться от встречи автоматически.

Если преследующая группа больше вашей – проверочное число становится на 1 пункт меньше, если меньше – на 1 пункт больше. Труднопроходимая местность также уменьшает шансы, пропорционально сложности преодоления преград. Лес, к примеру, уменьшит проверку на 1, в то время как джунгли – сразу на 2.

Если вам не нравятся ваши шансы, можно разбить свою группу на более мелкие, чтобы повысить шансы к «пряткам». Конечно, преследователи тоже могут провернуть этот трюк… но если они вас догонят, их, по крайней мере, будет меньше.

Дополнительные таблицы для возможных столкновений
Реакция противника
Когда вы сталкиваетесь с потенциально враждебными НИП или существами (см. Возможное столкновение), они не обязательно будут сразу же вас атаковать. Все зависит от вашего поведения, места и времени. Если во время войны с соседним королевством вы наткнетесь на  военный патруль, на их территории, вас не спасет никакая проверка реакции. В то же время даже самые злобные «гвардейцы кардинала» из враждующей фракции не станут нападать на вас просто так, посреди городского праздника.

Бросок 2d6	Реакция чудовища/НИП	Поведение
2	Враждебная / Атака	Ни на что не соглашается, атакует при малейшей угрозе (с его точки зрения).
3-5	Не дружественная / Готовность к атаке	Ни на что не соглашается, стоит на своем.
6-8	Нейтральная / Нельзя сказать точно	Сомневается. Можно попробовать ещё раз, с лучшим предложением
9-11	Безразличная / Вы не вызываете его интереса	Допускает возможность
12	Дружелюбная / Эй, давай дружить	Он согласен
"""


CONFIG = {
    'roll_on_double': True,
}


class Fraction:
    def __init__(self):
        self.surprised = False


class Distance:
    def __init__(
        self,
        description=None,
        distance_dice=None,
        multiplier=30,
        can_run=True,
    ):
        self.description = description
        self.distance_dice = distance_dice
        self.multiplier = multiplier
        self.can_run = can_run

    def generate(self):
        if self.distance_dice is None:
            return 0
        return next(self.distance_dice.roll()) * self.multiplier


class Encounter:
    description = None
    distances = [
        Distance(
            "Нос к носу (ближний бой возможен с ходу)",
            Dice(1, 6),
            1,
            True,
        ),
        Distance(
            "На расстоянии нескольких шагов (минимальный предел дистанционного боя без штрафов)",
            Dice(1, 6),
            3,
            True,
        ),
        Distance(
            "Среднее (1d6 х 30 футов, на дистанции прямого выстрела)",
            Dice(1, 6),
            30,
        ),
        Distance(
            "Дальнее (2d6+6 х 30 футов, вне прямой видимости)",
            Dice(2, 6, modifier=6),
            30,
        ),
        Distance(
            "Сверхдальнее (2d6+12 х 30 футов, вне прямой видимости)",
            Dice(2, 6, modifier=12),
            30,
        ),
        Distance(
            "На пределе видимости (10 минут бодрым шагом, вне прямой видимости)",
            Dice(1, 3),
            1200,
        ),
    ]

    def __init__(
        self,
        distance_type=None,
        distance=None,
    ):
        self.distance_type = distance_type
        self.__distance = distance

    @property
    def distance(self):
        if self.__distance is None:
            self.__distance = self.distance_type.generate() if self.distance_type else None
        return self.__distance

    @distance.setter
    def distance(self, value):
        self.__distance = value

    @property
    def meters(self):
        return int(self.distance / 3)

    @classmethod
    def generate(cls, *fractions, distances=None):
        for fraction in fractions:
            fraction.surprised = next(Dice().roll()) < 2
        distances = distances or cls.distances
        encounter = cls(
            distance_type=random.choice(distances),
        )
        return encounter

    def __str__(self):
        return "Расстояние:\t{} м\n{}\n".format(self.distance, self.description)


class ClashEncounter(Encounter):
    description = "Столкновение – хо-хо, а вот и орки. В смысле, сейчас будет драка."
    """
    Возможное столкновение – при неблагоприятных условиях, плохих бросках, 
    злобном ведущем и т.п. ситуациях, используйте этот вариант. В принципе, он 
    ничем не отличается от первоначального, кроме одного – вам предстоит 
    встреча с кем-то совершенно не в духе. При «путевой встрече» это могут 
    быть нечистые на руку караванщики, которые, если группа искателей 
    приключений кажется им легкой добычей, нападут. При «привале» — герои 
    встретятся с облюбовавшим это же место медведем или патрулем зверолюдей.
    """


class MeetEncounter(ClashEncounter):
    # http://stormtower.ru/interesnyie-mesta/tipyi-landshafta-dlya-odinochnyih-i-massovyih-srazheniy.html
    description = "Путевая встреча – не связанное с «военными действиями» " \
                  "событие, характерное для этой местности. Встреча с " \
                  "купеческими караванами на дороге или с дровосеком в лесу – " \
                  "вот и все примеры."


class HaltEncounter(ClashEncounter):
    description = "Привал – если вы сейчас же не сделаете привал (короткий, на " \
                  "1 час), то или лошадь захромает, или уровень усталости " \
                  "группы повысится."


class HintEncounter(Encounter):
    description = "Подсказка – вы получили относительно ценную информацию. " \
                  "Узнали о том, что поблизости чудовища, что рядом находится " \
                  "деревня, что недавно здесь проходил путешественник и т.п."


class WasteEncounter(Encounter):
    # http://stormtower.ru/sovetyi-vedushhemu-i-igroku-nri/priklyucheniya-pripasyi-kak-sovershit-podvig-poka-ne-konchilas-eda.html
    description = "Трата ресурсов – ох, в пути возникла ситуация, когда вам " \
                  "пришлось израсходовать часть ресурсов: запас дров, " \
                  "дополнительные порции провианта, веревку и т.п."


class DelayEncounter(Encounter):
    description = "Задержка в пути — что-то пошло не так и вы потеряли время, " \
                  "заблудились, вынуждены идти кружным путем, подвернули ногу " \
                  "и т.п."


class EncounterTime:
    min_time = 0
    max_time = 24
    available_encounters = [
        ClashEncounter,
        MeetEncounter,
        HaltEncounter,
        HintEncounter,
        WasteEncounter,
        DelayEncounter,
    ]
    encounter_distances = Encounter.distances

    def __init__(self, encounter=None):
        self.__encounter_type = encounter

    @property
    def distance(self):
        return 0

    @property
    def time(self):
        return self.distance * 6

    @property
    def encounter(self):
        if self.__encounter_type is None:
            self.__encounter_type = random.choice(self.available_encounters)
        return self.__encounter_type

    @encounter.setter
    def encounter(self, value):
        self.__encounter_type = value

    def generate(self, *fractions):
        return self.encounter.generate(
            *fractions,
            distances=self.encounter_distances,
        )


class DailyEncounter(EncounterTime):
    # http://stormtower.ru/generator/generator-sluchaynyih-vstrech-v-doroge.html
    min_time = 6
    encounter_distances = Encounter.distances[:6]

    def __init__(
        self,
        encounter=None,
        distance=None,
        max_distance=20,
    ):
        super().__init__(encounter=encounter)
        self.max_distance = max_distance
        self.__distance = distance

    @property
    def distance(self):
        if self.__distance is None:
            self.__distance = next(Dice(max_value=20).roll())
        return self.__distance % self.max_distance + 1

    @distance.setter
    def distance(self, value):
        self.__distance = value

    def __str__(self):
        time = "{} мин.".format(self.time % 60)
        hours = int(self.time / 60)
        if hours:
            time = "{} ч. {}".format(hours, time)

        encounter = self.generate(Fraction(), Fraction())
        return "Столкновение после {} миль пути ({})\n{}".format(self.distance, time, encounter)


class NightlyEncounter(EncounterTime):
    max_time = 6
    encounter_distances = Encounter.distances[:4]
    available_encounters = [
        ClashEncounter,
        MeetEncounter,
    ]

    def __init__(
        self,
        encounter=None,
        hours=None,
    ):
        super().__init__(encounter=encounter)
        self.__hours = hours

    @property
    def hours(self):
        if self.__hours is None:
            self.__hours = next(Dice(max_value=6).roll()) - 1
        return self.__hours % self.max_time

    @hours.setter
    def hours(self, value):
        self.__hours = value

    @property
    def time(self):
        return self.hours * 60

    def __str__(self):
        encounter = self.generate(Fraction(), Fraction())
        return "Столкновение после {} часов отдыха\n{}".format(self.hours, encounter)


def add_encounters(daily=1, nightly=1):
    next_roll = CONFIG.get('roll_on_double', False)
    dice1, dice2 = Dice(count=2).roll()
    print(dice1, dice2)

    if dice1 != dice2:
        next_roll = False
    elif dice1 % 2:
        nightly += 1
    else:
        daily += 1

    return add_encounters(daily, nightly) if next_roll else (daily, nightly)


def encounters(days=1, start_at_day=True, end_at_night=True):
    for day in range(days):
        print(day, "of", days)

        daily, nightly = add_encounters()

        if day == 0 and not start_at_day:
            daily = 0
        if day == days - 1 and not end_at_night:
            nightly = 0

        daily_encounters = [DailyEncounter() for _ in range(daily)]
        yield from sorted(daily_encounters, key=lambda encounter: encounter.time)

        nightly_encounters = [NightlyEncounter() for _ in range(nightly)]
        yield from sorted(nightly_encounters, key=lambda encounter: encounter.time)
